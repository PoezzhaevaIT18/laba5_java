<pre>
Лабораторная 5
  
1 задание. Шаблоны.
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида “числитель/знаменатель”
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.
Используется:
1)	Fraction - класс дроби с числителем и знаменателем.
•	Корректно обрабатывает отрицательные значения.
•	Проверяет, чтобы знаменатель не был равен нулю.
•	Реализует методы getDecimalValue(), setFraction(), toString(), equals(), hashCode.
2)	FractionCached - паттерн для кэширования вещественного значения дроби.
•	Значение вычисляется один раз при первом вызове.
•	При изменении дроби кэш автоматически сбрасывается.
3)	Check - класс для безопасного ввода данных:
•	Ввод числителя и знаменателя дроби с проверкой корректности.
•	Обработка отрицательного знаменателя.
Пользователь вводит две дроби. Программа выводит их значения и сравнивает дроби. Демонстрируется работа кэша для дроби и его обновление после изменения числителя или знаменателя.
Пример:
Работа с дробями: 
Введите первую дробь:
Введите числитель: 77
Введите знаменатель (не может быть 0): 100
Первая дробь: 77/100
Вещественное значение: 0.77
Введите вторую дробь:
Введите числитель: 6
Введите знаменатель (не может быть 0): -33
Вторая дробь: -6/33
Дроби равны? false
Кэш 1: 0.77
Кэш 2 (повторный вызов, без пересчета): 0.77
Новая дробь (через кэш): -6/10
Кэш пересчитан: -0.6

2 задание. Структурные шаблоны.
Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим количество мяуканий на экран. Кота изменять нельзя.
Если раннее в вашем варианте не было Кота, то создайте
1.	сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, вызвать мяуканье можно без параметров.
2.	интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой: public void meow();
Используется:
1)	Cat - класс кота.
•	Имеет имя (name).
•	Мяукает через метод meow().
•	Может быть приведён к текстовой форме через toString().
•	Не хранит количество мяуканий.
2)	Meowable - интерфейс для всех объектов, способных мяукать.
•	Содержит метод meow().
•	Позволяет передавать котов в методы, которые вызывают мяуканье всех объектов.
3)	Human - класс человека, считающего количество мяуканий котов.
•	Метод makeMeow(Cat cat) вызывает мяуканье кота и увеличивает внутренний счётчик.
•	Метод getTotalMeowCount() возвращает общее количество мяуканий.
4)	MeowCounter - класс для вызова мяуканья у всех объектов, реализующих Meowable.
•	Метод makeAllMeow(Meowable[] meowables) вызывает meow() у каждого объекта в массиве.
Создаются коты с именами. Через объект Human коты мяукают, и человек подсчитывает количество мяуканий. Можно вызвать метод MeowCounter.makeAllMeow(), чтобы все коты мяукнули один раз. После выполнения метода можно узнать, сколько раз мяукнул кот через человека.
Пример:
кот: Тоша
Тоша: мяу!
Тоша: мяу!
Тоша: мяу!
Тоша: мяу!
Количество мяуканий кота кот: Тоша: 4

3 задание. Список.
3.3. Даны упорядоченные списки L1 и L2. Вставить элементы списка L2 в список L1, не нарушая его упорядоченности.
1) Check - класс для безопасного ввода данных:
•	Ввод чисел с проверкой корректности.
•	Ввод строк и чисел с проверкой упорядоченности.
•	Для строк упорядоченность проверяется по длине элементов.
•	Для чисел — по возрастанию.
2) OrderedList - класс для объединения двух упорядоченных списков:
•	Сохраняет исходный порядок элементов.
•	Для чисел: порядок по возрастанию.
•	Для строк: порядок по длине.
Вставляем элементы списка L2 в L1 не нарушая его упорядоченности, то есть в конце должен быть итоговый упорядоченный список состоящий из всех элементов. Используется 2 типа переменных: Integer и String. Оба описаны в примере работы программы.
Пример:
Работа с числами: 
Введите элементы первого списка L1 (по возрастанию):
12 1234 234567
Введите элементы второго списка L2 (по возрастанию):
0 23 456
Объединённый список чисел:
0 12 23 456 1234 234567 
Работа со строками: 
Введите элементы первого списка S1 (по возрастанию):
fg fghj sdfghj
Введите элементы второго списка S2 (по возрастанию):
sa dsffgd sadfghjkljhgfds
Объединённый список строк:
fg sa fghj sdfghj dsffgd sadfghjkljhgfds

6 задание. Очередь.
6.2. По списку L построить очередь (например, по списку из элементов 1, 2, 3 требуется построить очередь из элементов 1, 2, 3, 3, 2, 1).
Используем:
1)	 ListQueue<T> - класс для построения очереди из списка.
•	sourceList - исходный список элементов.
•	resultQueue - очередь с элементами в прямом и обратном порядке.
Методы:
•	getSourceList() - получить исходный список.
•	getResultQueue() - получить построенную очередь.
•	toString() - строковое представление объекта.
2)	Check - класс для безопасного ввода данных.
•	Ввод упорядоченного списка:
1)	Числа проверяются на возрастание.
2)	Строки проверяются по возрастанию длины.
Пример:
Пример с числами:
Введите числа по возрастанию через пробел:
0 11 280 1000
Исходный список: [0, 11, 280, 1000]
Построенная очередь: [0, 11, 280, 1000, 1000, 280, 11, 0]
Пример со строками:
Введите строки по возрастанию длины через пробел:
sdf ghjk ghhjjjjjjj
Исходный список: [sdf, ghjk, ghhjjjjjjj]
Построенная очередь: [sdf, ghjk, ghhjjjjjjj, ghhjjjjjjj, ghjk, sdf]
</pre>
